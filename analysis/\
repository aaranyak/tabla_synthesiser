/* load_file.c - loads the data from a .wav file into a signal */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "audio.h"


float *parse_wav_file(char *file_path, int *num_samples_out, int *sample_rate_out) {
    /* Parses a .wav file */
    int file_length; char *file_data; /* stuffs */
    FILE *handle = fopen(file_path, "rb"); /* Read from the file */
    for (file_length = 0; !feof(handle); fgetc(handle)) file_length++; rewind(handle); /* Get the file length */
    file_data = (char*)malloc(file_length); for (int i = 0; i < file_length; i++) file_data[i] = fgetc(handle); /* load file */
    fclose(handle); /* Now what? */

    // Now slowly load parts of the file in.
    int read_head = 0; /* Used for reading data from a file */
    char magic[5] = "    "; memcpy(magic, file_data, 4); read_head += 4; /* Read in the magic */
    if (strcmp(magic, "RIFF")) goto wav_parse_error; /* Check if this is a wav file */
    read_head += 8; /* Next choonk */
    // Get chunk positions
    int chunk_count = 0; char chunk_ids[10][5]; char *chunks[10]; int chunk_sizes[10]; /* Null terminated array of strings */
    for (int i = 0; i < 10; i++) chunk_ids[i][4] = 0; /* Add null terminators to this stuff */
    while (read_head < file_length - 1) { /* Loop through all the chunks in the file */
        memcpy(chunk_ids[chunk_count], file_data + read_head, 4); read_head += 4; /* Copy in chunk id */
        memcpy(&(chunk_sizes[chunk_count]), file_data + read_head, 4); read_head += 4; /* Copy in chunk size */
        chunks[chunk_count] = file_data + read_head; /* Current chunk offset */ 
        read_head += chunk_sizes[chunk_count]; /* Wow this chunk size thing makes programming soo much easier */
        chunk_count++; /* Yes there is another chunk (so afraid of an off-by-one right now) */
    } /* Done reading choonks */

    // Read fmt chunk.
    char *fmt_chunk; int fmt_size; /* Size and pointer to the fmt chunk (The line of code below does the job of getting them) */
    for (int i = 0; i < chunk_count; i++) if (!strcmp(chunk_ids[i], "fmt ")){fmt_chunk = chunks[i]; fmt_size = chunk_sizes[i];}
    // Now What? (ZZ9 Plural Z Alpha)
    unsigned int format = 0, channels = 0, sample_rate, sample_size = 0; read_head = 0; /* Time to load in these values */
    memcpy(&format, fmt_chunk + read_head, 2); read_head += 2; /* Read in the type */
    if (format != 1) goto wav_parse_error; /* Only support pcm ints */
    memcpy(&channels, fmt_chunk + read_head, 2); read_head += 2; /* Read in the no. of channels */
    memcpy(&sample_rate, fmt_chunk + read_head, 4); read_head += 4 + 6; /* Sample rate (skip over two values) */
    memcpy(&sample_size, fmt_chunk + read_head, 2); read_head = 0; /* Sample size */
    printf("Format - %d\nChannels - %d\nSample Rate - %d\nSample Size - %d\n", format, channels, sample_rate, sample_size);
    // Read data chunk
    char *data_chunk; int data_size; /* Size and pointer to the data chunk (The line of code below does the job of getting them) */
    for (int i = 0; i < chunk_count; i++) if (!strcmp(chunk_ids[i], "data")){data_chunk = chunks[i]; data_size = chunk_sizes[i];}
    int num_samples = data_size / (channels * (sample_size >> 3)); /* Calculate number of samples in a channel */
    printf("Num Samples - %d\n", num_samples); read_head = 0;
    float *samples = (float*)malloc(sizeof(float) * num_samples); /* Place where we put each sample */
    for (int i = 0; i < num_samples; i++) { /* Now we loop through all the samples in the first channel */
        switch (sample_size) { /* Handle different sizes differently */
            case 8: { /* Single byte sample */
                unsigned char raw_sample; /* Loaders and writers */
                memcpy(&raw_sample, data_chunk + read_head, 1); read_head += 1; /* Load in a sample */
                samples[i] = (float)raw_sample / 128.0 - 1.0; /* Value between -1.0 and 1.0 */
                //break;
            } case 16: { /* 16bit ints */
                int16_t raw_sample; memcpy(&raw_sample, data_chunk + read_head, 2); read_head += 2; /* Get sample */
                samples[i] = (float)raw_sample / 32768.0; /* Scale it down to between -1 and 1 */
               // break;
            } case 24: { /* 24bit ints (rather hard) */
                int32_t raw_sample = 0; memcpy(&raw_sample, data_chunk + read_head, 3); read_head += 3; /* Get sample */
                if (raw_sample & 0x00800000) raw_sample |= 0xFF000000; /* Two's-complement correction for 24bit ints */
                samples[i] = (float)raw_sample / 8388608.0; /* Scale it down to between -1 and 1 */
                //break;
            } case 32: { /* 32bit ints */
                int raw_sample; memcpy(&raw_sample, data_chunk + read_head, 4); read_head += 4; /* Get sample */
                //samples[i] = (float)raw_sample / 2147483648.0; /* Scale it down to between -1 and 1 */
            }
        } /* Read in the samples */
    }
    *num_samples_out = num_samples; *sample_rate_out = sample_rate; /* Read these */
    free(file_data); /* Done with these */
    return samples; /* Oh Well... */

wav_parse_error: /* Clean stuff up */
    printf("Sorry, not supported\n");
    free(file_data); /* Here you go */
    return 0; /* No pointer for you */
}

Signal *load_wav(char *path) {
    /* Load signal data from a file path */
    Signal *signal = (Signal*)malloc(sizeof(Signal)); /* Create an empty signal */
    signal->samples = parse_wav_file(path, (int*)&signal->length, &signal->rate); /* Parse the file */
    if (!signal->samples) { /* If it did not work */
        free(signal); return 0; /* Get out */
    }
    return signal;
}
